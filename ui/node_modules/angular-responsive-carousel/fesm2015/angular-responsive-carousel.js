import { EventEmitter, Component, ElementRef, ChangeDetectorRef, Input, Output, HostBinding, HostListener, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';

class Touches {
    constructor(properties) {
        this.eventType = undefined;
        this.handlers = {};
        this.startX = 0;
        this.startY = 0;
        this.lastTap = 0;
        this.doubleTapMinTimeout = 300;
        this.tapMinTimeout = 200;
        this.touchstartTime = 0;
        this.i = 0;
        this.isMousedown = false;
        this._touchListeners = {
            "touchstart": "handleTouchstart",
            "touchmove": "handleTouchmove",
            "touchend": "handleTouchend"
        };
        this._mouseListeners = {
            "mousedown": "handleMousedown",
            "mousemove": "handleMousemove",
            "mouseup": "handleMouseup",
            "wheel": "handleWheel"
        };
        this._otherListeners = {
            "resize": "handleResize"
        };
        /*
         * Listeners
         */
        /* Touchstart */
        this.handleTouchstart = (event) => {
            this.elementPosition = this.getElementPosition();
            this.touchstartTime = new Date().getTime();
            if (this.eventType === undefined) {
                this.getTouchstartPosition(event);
            }
            this.runHandler("touchstart", event);
        };
        /* Touchmove */
        this.handleTouchmove = (event) => {
            const touches = event.touches;
            // Pan
            if (this.detectPan(touches)) {
                this.runHandler("pan", event);
            }
            // Pinch
            if (this.detectPinch(event)) {
                this.runHandler("pinch", event);
            }
            // Linear swipe
            switch (this.detectLinearSwipe(event)) {
                case "horizontal-swipe":
                    event.swipeType = "horizontal-swipe";
                    this.runHandler("horizontal-swipe", event);
                    break;
                case "vertical-swipe":
                    event.swipeType = "vertical-swipe";
                    this.runHandler("vertical-swipe", event);
                    break;
            }
            // Linear swipe
            if (this.detectLinearSwipe(event) ||
                this.eventType === 'horizontal-swipe' ||
                this.eventType === 'vertical-swipe') {
                this.handleLinearSwipe(event);
            }
        };
        /* Touchend */
        this.handleTouchend = (event) => {
            const touches = event.touches;
            // Double Tap
            if (this.detectDoubleTap()) {
                this.runHandler("double-tap", event);
            }
            // Tap
            this.detectTap();
            this.runHandler("touchend", event);
            this.eventType = 'touchend';
            if (touches && touches.length === 0) {
                this.eventType = undefined;
                this.i = 0;
            }
        };
        /* Mousedown */
        this.handleMousedown = (event) => {
            this.isMousedown = true;
            this.elementPosition = this.getElementPosition();
            this.touchstartTime = new Date().getTime();
            if (this.eventType === undefined) {
                this.getMousedownPosition(event);
            }
            this.runHandler("mousedown", event);
        };
        /* Mousemove */
        this.handleMousemove = (event) => {
            //event.preventDefault();
            if (!this.isMousedown) {
                return;
            }
            // Pan
            this.runHandler("pan", event);
            // Linear swipe
            switch (this.detectLinearSwipe(event)) {
                case "horizontal-swipe":
                    event.swipeType = "horizontal-swipe";
                    this.runHandler("horizontal-swipe", event);
                    break;
                case "vertical-swipe":
                    event.swipeType = "vertical-swipe";
                    this.runHandler("vertical-swipe", event);
                    break;
            }
            // Linear swipe
            if (this.detectLinearSwipe(event) ||
                this.eventType === 'horizontal-swipe' ||
                this.eventType === 'vertical-swipe') {
                this.handleLinearSwipe(event);
            }
        };
        /* Mouseup */
        this.handleMouseup = (event) => {
            // Tap
            this.detectTap();
            this.isMousedown = false;
            this.runHandler("mouseup", event);
            this.eventType = undefined;
            this.i = 0;
        };
        /* Wheel */
        this.handleWheel = (event) => {
            this.runHandler("wheel", event);
        };
        /* Resize */
        this.handleResize = (event) => {
            this.runHandler("resize", event);
        };
        this.properties = properties;
        this.element = this.properties.element;
        this.elementPosition = this.getElementPosition();
        this.toggleEventListeners('addEventListener');
    }
    get touchListeners() {
        return this.properties.touchListeners ? this.properties.touchListeners : this._touchListeners;
    }
    get mouseListeners() {
        return this.properties.mouseListeners ? this.properties.mouseListeners : this._mouseListeners;
    }
    get otherListeners() {
        return this.properties.otherListeners ? this.properties.otherListeners : this._otherListeners;
    }
    destroy() {
        this.toggleEventListeners('removeEventListener');
    }
    toggleEventListeners(action) {
        let listeners;
        if (this.properties.listeners === 'mouse and touch') {
            listeners = Object.assign(this.touchListeners, this.mouseListeners);
        }
        else {
            listeners = this.detectTouchScreen() ? this.touchListeners : this.mouseListeners;
        }
        if (this.properties.resize) {
            listeners = Object.assign(listeners, this.otherListeners);
        }
        for (var listener in listeners) {
            const handler = listeners[listener];
            // Window
            if (listener === "resize") {
                if (action === 'addEventListener') {
                    window.addEventListener(listener, this[handler], false);
                }
                if (action === 'removeEventListener') {
                    window.removeEventListener(listener, this[handler], false);
                }
                // Document
            }
            else if (listener === 'mouseup' || listener === "mousemove") {
                if (action === 'addEventListener') {
                    document.addEventListener(listener, this[handler], false);
                }
                if (action === 'removeEventListener') {
                    document.removeEventListener(listener, this[handler], false);
                }
                // Element
            }
            else {
                if (action === 'addEventListener') {
                    this.element.addEventListener(listener, this[handler], false);
                }
                if (action === 'removeEventListener') {
                    this.element.removeEventListener(listener, this[handler], false);
                }
            }
        }
    }
    addEventListeners(listener, handler) {
        window.addEventListener(listener, this[handler], false);
    }
    removeEventListeners(listener, handler) {
        window.removeEventListener(listener, this[handler], false);
    }
    handleLinearSwipe(event) {
        //event.preventDefault();
        this.i++;
        if (this.i > 3) {
            this.eventType = this.getLinearSwipeType(event);
        }
        if (this.eventType === 'horizontal-swipe') {
            this.runHandler('horizontal-swipe', event);
        }
        if (this.eventType === 'vertical-swipe') {
            this.runHandler('vertical-swipe', event);
        }
    }
    runHandler(eventName, response) {
        if (this.handlers[eventName]) {
            this.handlers[eventName](response);
        }
    }
    /*
     * Detection
     */
    detectPan(touches) {
        return touches.length === 1 && !this.eventType || this.eventType === 'pan';
    }
    detectDoubleTap() {
        if (this.eventType != undefined) {
            return;
        }
        const currentTime = new Date().getTime();
        const tapLength = currentTime - this.lastTap;
        clearTimeout(this.doubleTapTimeout);
        if (tapLength < this.doubleTapMinTimeout && tapLength > 0) {
            return true;
        }
        else {
            this.doubleTapTimeout = setTimeout(() => {
                clearTimeout(this.doubleTapTimeout);
            }, this.doubleTapMinTimeout);
        }
        this.lastTap = currentTime;
    }
    detectTap() {
        if (this.eventType != undefined) {
            return;
        }
        const currentTime = new Date().getTime();
        const tapLength = currentTime - this.touchstartTime;
        if (tapLength > 0) {
            if (tapLength < this.tapMinTimeout) {
                this.runHandler("tap", event);
            }
            else {
                this.runHandler("longtap", event);
            }
        }
    }
    detectPinch(event) {
        const touches = event.touches;
        return (touches.length === 2 && this.eventType === undefined) || this.eventType === 'pinch';
    }
    detectLinearSwipe(event) {
        const touches = event.touches;
        if (touches) {
            if (touches.length === 1 && !this.eventType || this.eventType === 'horizontal-swipe' || this.eventType === 'vertical-swipe') {
                return this.getLinearSwipeType(event);
            }
        }
        else {
            if (!this.eventType || this.eventType === 'horizontal-swipe' || this.eventType === 'vertical-swipe') {
                return this.getLinearSwipeType(event);
            }
        }
    }
    getLinearSwipeType(event) {
        if (this.eventType !== 'horizontal-swipe' && this.eventType !== 'vertical-swipe') {
            const movementX = Math.abs(this.moveLeft(0, event) - this.startX);
            const movementY = Math.abs(this.moveTop(0, event) - this.startY);
            if ((movementY * 3) > movementX) {
                return 'vertical-swipe';
            }
            else {
                return 'horizontal-swipe';
            }
        }
        else {
            return this.eventType;
        }
    }
    getElementPosition() {
        return this.element.getBoundingClientRect();
    }
    getTouchstartPosition(event) {
        this.startX = event.touches[0].clientX - this.elementPosition.left;
        this.startY = event.touches[0].clientY - this.elementPosition.top;
    }
    getMousedownPosition(event) {
        this.startX = event.clientX - this.elementPosition.left;
        this.startY = event.clientY - this.elementPosition.top;
    }
    moveLeft(index, event) {
        const touches = event.touches;
        if (touches) {
            return touches[index].clientX - this.elementPosition.left;
        }
        else {
            return event.clientX - this.elementPosition.left;
        }
    }
    moveTop(index, event) {
        const touches = event.touches;
        if (touches) {
            return touches[index].clientY - this.elementPosition.top;
        }
        else {
            return event.clientY - this.elementPosition.top;
        }
    }
    detectTouchScreen() {
        var prefixes = ' -webkit- -moz- -o- -ms- '.split(' ');
        var mq = function (query) {
            return window.matchMedia(query).matches;
        };
        if (('ontouchstart' in window)) {
            return true;
        }
        // include the 'heartz' as a way to have a non matching MQ to help terminate the join
        // https://git.io/vznFH
        var query = ['(', prefixes.join('touch-enabled),('), 'heartz', ')'].join('');
        return mq(query);
    }
    /* Public properties and methods */
    on(event, handler) {
        if (event) {
            this.handlers[event] = handler;
        }
    }
}

class Carousel {
    constructor(properties) {
        this.initialPositionX = 0;
        /* The index of the new position relative to the active index, for example -1 or +1 */
        this.newContainerPositionIndex = 0;
        this.preliminarySlideCounter = 0;
        /* Scrolling Index (counter) */
        this.slideCounter = 0;
        this.previousSlideCounter = 0;
        this.isContentImages = true;
        this.isLazyLoad = true;
        this.isContainerLocked = true;
        this.alignCells = "left";
        this.initialContainerPosition = 0;
        this.handleTouchstart = (event) => {
            this.isTouchstart = true;
            this.startX = this.getStartX(event);
            this.containerInitialPositionX = this.getElementPosition()['left'] - this.getCarouselElementPosition()['left'];
            this.isMoveInProgress = true;
            this.stopTransformContainer();
        };
        this.handleHorizontalSwipe = (event) => {
            const touches = event.touches;
            if (touches) {
                this.moveX = touches[0].clientX - this.getCarouselElementPosition()['left'];
            }
            else {
                this.moveX = event.clientX - this.getCarouselElementPosition()['left'];
            }
            this.distanceAbs = this.getDistanceAbs();
            this.direction = this.getDirection();
            this.moveContainer();
        };
        this.handleTouchend = (event) => {
            if (!this.isTouchstart) {
                this.isTouchstart = false;
                return;
            }
            this.isMoveInProgress = false;
            if (this.detectSlide()) {
                this.handleSlide();
            }
            else {
                this.newContainerPositionIndex = 0;
                this.alignContainer();
            }
            this.startX = this.moveX = this.distanceAbs = undefined;
            this.isTouchstart = false;
        };
        this.element = properties.element;
        this.properties = properties;
        this.cells = this.element.children;
        this.visibleWidth = this.properties.visibleWidth || this.element.parentElement.clientWidth;
        this.setContainerWidth();
        this.alignContainer(0);
    }
    get cellLength() {
        if (this.images) {
            return this.images.length;
        }
        else {
            return this.cells.length;
        }
    }
    get totalContainerCellsCount() {
        if (this.images) {
            let cellLength = this.visibleCellsCount + this.overflowCellsLimit * 2;
            if (cellLength > this.images.length) {
                cellLength = this.images.length;
            }
            return cellLength;
        }
        else {
            return this.cellLength;
        }
    }
    get isFirstCell() {
        return this.slideCounter === 0;
    }
    get lastCellIndex() {
        return this.images.length ? (this.images.length - 1) : (this.cells.length - 1);
    }
    get overflowCellsLimit() {
        if (this.images && this.isImagesLessCellLimit) {
            return Math.floor((this.images.length - this.visibleCellsCount) / 2);
        }
        else {
            return this.properties.overflowCellsLimit;
        }
    }
    get isImagesLessCellLimit() {
        return this.properties.overflowCellsLimit * 2 + this.visibleCellsCount > this.images.length;
    }
    get cellLimit() {
        return this.visibleCellsCount + this.overflowCellsLimit * 2;
    }
    get images() {
        return this.properties.images;
    }
    get margin() {
        return this.properties.margin;
    }
    get minSwipeDistance() {
        return this.properties.minSwipeDistance;
    }
    get transitionDuration() {
        return this.properties.transitionDuration;
    }
    get transitionTimingFunction() {
        return this.properties.transitionTimingFunction;
    }
    get fullCellWidth() {
        return this.properties.cellWidth + this.margin;
    }
    get visibleCellsCount() {
        return Math.ceil(this.visibleWidth / this.fullCellWidth);
    }
    get lapCounter() {
        return Math.floor(this.slideCounter / this.totalContainerCellsCount);
    }
    get visibleCellsOverflowContainer() {
        return (this.visibleCellsCount * this.fullCellWidth - this.margin) > this.visibleWidth;
    }
    stopTransformContainer() {
        this.transformPositionX(this.containerInitialPositionX, 0);
        this.setSlideCounter();
        this.isSlideInProgress = false;
        this.newContainerPositionIndex = 0;
        this.isSlideLengthLimited = undefined;
    }
    getStartX(event) {
        const touches = event.touches;
        let startX;
        if (touches) {
            startX = touches[0].clientX - this.getCarouselElementPosition()['left'];
        }
        else {
            startX = event.clientX - this.getCarouselElementPosition()['left'];
        }
        return startX;
    }
    /* Move */
    moveContainer() {
        let positionX = this.getMovePositionX();
        this.transformPositionX(positionX, 0);
    }
    getMovePositionX() {
        const distance = this.getDistance();
        return this.containerInitialPositionX - distance;
    }
    /* Align */
    alignContainer(duration = this.transitionDuration) {
        let positionX = this.getContainerPosition();
        this.transformPositionX(positionX, duration);
        this.setInitialContainerPosition(positionX);
    }
    getContainerPosition() {
        let correction = this.getContainerPositionCorrection();
        this.isContainerPositionCorrection = correction != 0;
        return (this.initialContainerPosition + this.newContainerPositionIndex * this.fullCellWidth) + correction;
    }
    setInitialContainerPosition(position) {
        let correction = this.getContainerPositionCorrection();
        this.initialContainerPosition = position - correction;
    }
    /* Offset the container to show the last cell completely */
    getContainerPositionCorrection() {
        let correction = 0;
        if (this.properties.loop) {
            return 0;
        }
        if ((this.cellLength - this.preliminarySlideCounter) < this.visibleCellsCount || this.isSlideLengthLimited) {
            if (this.visibleWidth < this.totalContainerCellsCount * this.fullCellWidth) {
                correction = -(this.visibleCellsCount * this.fullCellWidth - this.visibleWidth - this.margin);
            }
            if (correction >= -this.margin) {
                correction = 0;
            }
        }
        return correction;
    }
    /* Quickly center */
    quicklyPositionContainer() {
        let correction = this.getContainerPositionCorrection();
        const initialPosition = this.getNewContainerPosition() + correction;
        this.transformPositionX(initialPosition, 0);
        this.setInitialContainerPosition(initialPosition);
    }
    getNewContainerPosition() {
        if (this.slideCounter > this.overflowCellsLimit) {
            if (this.alignCells === "left") {
                this.lineUpCells();
                return -(this.overflowCellsLimit * this.fullCellWidth);
            }
        }
        if (this.slideCounter <= this.overflowCellsLimit) {
            if (this.previousSlideCounter > this.overflowCellsLimit) {
                this.lineUpCells();
            }
            return -(this.slideCounter * this.fullCellWidth);
        }
    }
    setContainerWidth() {
        const containerWidth = this.getContainerWidth();
        this.element.style.width = containerWidth + "px";
    }
    getContainerWidth() {
        let containerWidth = this.totalContainerCellsCount * this.fullCellWidth;
        let totalImageWidth = this.cellLength * this.fullCellWidth;
        if (totalImageWidth < containerWidth) {
            containerWidth = totalImageWidth;
        }
        return containerWidth;
    }
    getFile(cellIndex) {
        let imageIndex = this.getFileIndex(cellIndex);
        let file = this.images[imageIndex];
        if (file && !file.type) {
            file.type = 'image';
        }
        return {
            image: this.images[imageIndex],
            imageIndex
        };
    }
    getFileIndex(cellIndex) {
        const positionIndex = this.getPositionIndex(cellIndex);
        const numberLeftCells = (this.totalContainerCellsCount - 1) / 2;
        let imageIndex;
        let counter = this.slideCounter;
        if (!this.isContainerLocked) {
            if (counter <= this.overflowCellsLimit) {
                return cellIndex;
            }
            else {
                let cellLimitOverflow = counter - this.overflowCellsLimit;
                imageIndex = positionIndex + cellLimitOverflow;
                if (this.images && this.properties.loop) {
                    imageIndex = imageIndex % this.images.length;
                }
                return imageIndex;
            }
        }
        if (this.alignCells === "left") {
            if (counter > this.overflowCellsLimit) {
                let cellLimitOverflow = counter - this.overflowCellsLimit;
                imageIndex = positionIndex + cellLimitOverflow;
            }
            else {
                imageIndex = cellIndex;
            }
        }
        if (imageIndex > this.lastCellIndex && !this.properties.loop) {
            return false;
        }
        return imageIndex;
    }
    transformPositionX(value, duration = this.transitionDuration) {
        this.element.style.transition = 'transform ' + duration + 'ms ' + this.transitionTimingFunction;
        this.element.style.transform = 'translateX(' + value + 'px)';
    }
    detectSlide() {
        return this.distanceAbs >= this.minSwipeDistance;
    }
    next(length = 1) {
        this.newContainerPositionIndex = 0;
        this.direction = 'left';
        this.handleSlide(length);
    }
    prev(length = 1) {
        this.newContainerPositionIndex = 0;
        this.direction = 'right';
        this.handleSlide(length);
    }
    select(index) {
        this.slideCounter = index;
        this.quicklyPositionContainer();
    }
    handleSlide(customSlideLength = undefined) {
        let isUsingButton = customSlideLength;
        if (isUsingButton && this.isSlideInProgress) {
            return;
        }
        this.slideLength = customSlideLength ? customSlideLength : this.limitSlideLength(this.getSlideLength());
        if (this.direction === 'left') {
            this.handleLeftSlide();
        }
        if (this.direction === 'right') {
            this.handleRightSlide();
        }
        this.alignContainer();
    }
    handleLeftSlide() {
        this.preliminarySlideCounter = this.slideCounter + this.slideLength;
        let isLastSlide = this.detectLastSlide(this.slideCounter + this.slideLength);
        if (!isLastSlide) {
            this.newContainerPositionIndex = this.newContainerPositionIndex - this.slideLength;
            this.isSlideInProgress = true;
            if (this.isLazyLoad) {
                this.isContainerLocked = this.preliminarySlideCounter > this.overflowCellsLimit;
                if (this.detectContainerUnlock()) {
                    this.isContainerLocked = false;
                }
            }
        }
        else {
            this.slideLength = 0;
        }
    }
    handleRightSlide() {
        if (this.slideCounter - this.slideLength < 0) {
            this.slideLength = this.slideCounter;
        }
        this.preliminarySlideCounter = this.slideCounter - this.slideLength;
        if (!this.isFirstCell) {
            this.newContainerPositionIndex = this.newContainerPositionIndex + this.slideLength;
            this.isSlideInProgress = true;
            if (this.isLazyLoad) {
                if (this.preliminarySlideCounter > this.overflowCellsLimit) {
                    this.isContainerLocked = true;
                }
                else {
                    this.isContainerLocked = false;
                }
                if (this.detectContainerUnlock()) {
                    this.isContainerLocked = false;
                }
            }
        }
        else {
            this.slideLength = 0;
        }
    }
    getSlideLength() {
        let correction = this.getContainerPositionCorrection();
        let length = Math.floor((this.distanceAbs + correction) / this.fullCellWidth);
        if (this.distanceAbs % this.fullCellWidth >= this.minSwipeDistance) {
            length++;
        }
        return length;
    }
    /*
     * Limits the length of the slide during calls to the next() and prev()
     * methods if the specified position is outside the cell length
     */
    limitSlideLength(slideLength) {
        if (slideLength > 1) {
            for (var i = 0; i < slideLength; i++) {
                let newSlideCounter = this.slideCounter + (slideLength - i);
                if (!this.detectLastSlide(newSlideCounter)) {
                    slideLength = slideLength - i;
                    this.isSlideLengthLimited = i > 0;
                    break;
                }
            }
        }
        return slideLength;
    }
    detectLastSlide(slideCounter) {
        if (this.properties.loop) {
            return false;
        }
        else {
            return (this.cellLength - slideCounter) < this.visibleCellsCount;
        }
    }
    isNextArrowDisabled() {
        if (this.visibleCellsOverflowContainer) {
            return this.detectLastSlide(this.slideCounter + 1) && this.isContainerPositionCorrection;
        }
        else {
            return this.detectLastSlide(this.slideCounter + 1);
        }
    }
    isPrevArrowDisabled() {
        return this.slideCounter === 0;
    }
    detectContainerUnlock() {
        return (this.cellLength - this.preliminarySlideCounter) < (this.visibleCellsCount + this.overflowCellsLimit);
    }
    handleSlideEnd() {
        if (this.isSlideInProgress) {
            this.transformSlideEnd();
            this.isSlideInProgress = false;
            this.newContainerPositionIndex = 0;
            this.isSlideLengthLimited = undefined;
        }
    }
    transformSlideEnd() {
        if (this.isLazyLoad) {
            this.setSlideCounter();
            if (this.images || !this.images && this.properties.loop) {
                this.quicklyPositionContainer();
            }
        }
        this.previousSlideCounter = this.slideCounter;
    }
    setSlideCounter() {
        if (this.direction === 'left') {
            this.slideCounter = this.slideCounter + this.slideLength;
        }
        if (this.direction === 'right') {
            this.slideCounter = this.slideCounter - this.slideLength;
        }
        this.direction = undefined;
        this.slideLength = 0;
    }
    resetTransition() {
        this.element.style.transition = '';
    }
    getElementPosition() {
        return this.element.getBoundingClientRect();
    }
    getCarouselElementPosition() {
        return this.properties.container.getBoundingClientRect();
    }
    getDistance() {
        return this.startX - this.moveX;
    }
    getDistanceAbs() {
        return Math.abs(this.startX - this.moveX);
    }
    getDirection() {
        const direction = Math.sign(this.startX - this.moveX);
        if (direction === -1) {
            return 'right';
        }
        if (direction === 1) {
            return 'left';
        }
    }
    lineUpCells() {
        const cells = this.element.children;
        for (var i = 0; i < cells.length; i++) {
            let cell = cells[i];
            let positionX = this.getCellPositionX(i);
            cell.style.transform = 'translateX(' + positionX + 'px)';
            // notice
            cell.style.width = this.properties.cellWidth + 'px';
        }
        ;
    }
    getCellPositionX(index) {
        let positionIndex = this.getPositionIndex(index);
        return positionIndex * this.fullCellWidth;
    }
    getPositionIndex(cellIndex) {
        let counter = this.slideCounter;
        let cellLength = this.totalContainerCellsCount;
        let slideCounter = counter - this.overflowCellsLimit;
        let positionIndex;
        if (slideCounter > cellLength) {
            slideCounter = slideCounter % cellLength;
        }
        if (slideCounter < 0) {
            return cellIndex;
        }
        else {
            positionIndex = cellIndex - slideCounter;
            if (positionIndex < 0) {
                positionIndex = cellLength + positionIndex;
            }
        }
        return positionIndex;
    }
    getCenterPositionIndex() {
        return (this.totalContainerCellsCount - 1) / 2;
    }
    autoplay() {
        this.autoplayId = setInterval(() => {
            this.next();
        }, this.properties.autoplayInterval);
    }
    stopAutoplay() {
        if (this.autoplayId) {
            clearInterval(this.autoplayId);
        }
    }
    destroy() {
        this.stopAutoplay();
    }
}

class CarouselComponent {
    constructor(elementRef, ref) {
        this.elementRef = elementRef;
        this.ref = ref;
        this.minTimeout = 30;
        this._cellWidth = 200;
        this.events = new EventEmitter();
        this.height = 200;
        this.loop = false;
        this.autoplay = false;
        this.autoplayInterval = 5000;
        this.pauseOnHover = true;
        this.dots = false;
        this.margin = 10;
        this.objectFit = 'cover';
        this.minSwipeDistance = 10;
        this.transitionDuration = 200;
        this.transitionTimingFunction = 'ease';
        this.counterSeparator = " / ";
        this.overflowCellsLimit = 3;
        this.listeners = 'mouse and touch';
        this.cellsToScroll = 1;
        this.arrows = true;
        this.arrowsTheme = 'light';
        this.hostClassCarousel = true;
        /* Touchstart */
        this.handleTouchstart = (event) => {
            //event.preventDefault();
            this.touches.addEventListeners("mousemove", "handleMousemove");
            this.carousel.handleTouchstart(event);
            this.isMoving = true;
        };
        /* Touchmove */
        this.handleHorizontalSwipe = (event) => {
            event.preventDefault();
            this.carousel.handleHorizontalSwipe(event);
        };
        /* Touchend */
        this.handleTouchend = (event) => {
            const touches = event.touches;
            this.carousel.handleTouchend(event);
            this.touches.removeEventListeners("mousemove", "handleMousemove");
            this.isMoving = false;
        };
    }
    get isContainerLocked() {
        return this.carousel.isContainerLocked;
    }
    get slideCounter() {
        return this.carousel.slideCounter;
    }
    get previousSlideCounter() {
        return this.carousel.previousSlideCounter;
    }
    get lapCounter() {
        return this.carousel.lapCounter;
    }
    lineUpCells() {
        this.carousel.lineUpCells();
    }
    quicklyPositionContainer() {
        this.carousel.quicklyPositionContainer();
    }
    get isLandscape() {
        return window.innerWidth > window.innerHeight;
    }
    get isSafari() {
        const ua = navigator.userAgent.toLowerCase();
        if (ua.indexOf('safari') !== -1) {
            return !(ua.indexOf('chrome') > -1);
        }
    }
    get counter() {
        let counter;
        if (this.loop) {
            counter = this.slideCounter % this.cellLength;
        }
        else {
            counter = this.slideCounter;
        }
        return counter + 1 + this.counterSeparator + this.cellLength;
    }
    get cellsElement() {
        return this.elementRef.nativeElement.querySelector('.carousel-cells');
    }
    set images(images) {
        this._images = images;
    }
    get images() {
        return this._images;
    }
    set cellWidth(value) {
        if (value) {
            this._cellWidth = value;
        }
    }
    set isCounter(value) {
        if (value) {
            this._isCounter = value;
        }
    }
    get isCounter() {
        return this._isCounter && this.cellLength > 1;
    }
    get activeDotIndex() {
        return this.slideCounter % this.cellLength;
    }
    get cellLimit() {
        if (this.carousel) {
            return this.carousel.cellLimit;
        }
    }
    onWindowResize(event) {
        this.landscapeMode = this.isLandscape;
        this.ref.detectChanges();
        this.initCarousel();
        this.carousel.lineUpCells();
    }
    onMousemove(event) {
        if (this.autoplay && this.pauseOnHover) {
            this.carousel.stopAutoplay();
        }
    }
    onMouseleave(event) {
        if (this.autoplay && this.pauseOnHover) {
            this.carousel.autoplay();
        }
    }
    ngOnInit() {
        this.isNgContent = this.cellsElement.children.length > 0;
        this.touches = new Touches({
            element: this.cellsElement,
            listeners: this.listeners,
            mouseListeners: {
                "mousedown": "handleMousedown",
                "mouseup": "handleMouseup"
            }
        });
        this.touches.on('touchstart', this.handleTouchstart);
        this.touches.on('horizontal-swipe', this.handleHorizontalSwipe);
        this.touches.on('touchend', this.handleTouchend);
        this.touches.on('mousedown', this.handleTouchstart);
        this.touches.on('mouseup', this.handleTouchend);
        this.initCarousel();
        this.setDimensions();
        if (this.autoplay) {
            this.carousel.autoplay();
        }
    }
    ngAfterViewInit() {
        this.cellLength = this.getCellLength();
        this.dotsArr = Array(this.cellLength).fill(1);
        this.ref.detectChanges();
        this.carousel.lineUpCells();
        /* Start detecting changes in the DOM tree */
        this.detectDomChanges();
    }
    ngOnChanges(changes) {
        if (changes.width || changes.height || changes.images) {
            this.setDimensions();
            this.initCarousel();
            this.carousel.lineUpCells();
            this.ref.detectChanges();
        }
    }
    ngOnDestroy() {
        this.touches.destroy();
        this.carousel.destroy();
    }
    initCarousel() {
        this.carousel = new Carousel({
            element: this.elementRef.nativeElement.querySelector('.carousel-cells'),
            container: this.elementRef.nativeElement,
            images: this.images,
            cellWidth: this.getCellWidth(),
            loop: this.loop,
            autoplayInterval: this.autoplayInterval,
            overflowCellsLimit: this.overflowCellsLimit,
            visibleWidth: this.width,
            margin: this.margin,
            minSwipeDistance: this.minSwipeDistance,
            transitionDuration: this.transitionDuration,
            transitionTimingFunction: this.transitionTimingFunction,
            videoProperties: this.videoProperties
        });
    }
    detectDomChanges() {
        const observer = new MutationObserver((mutations) => {
            this.onDomChanges();
        });
        var config = {
            attributes: true,
            childList: true,
            characterData: true
        };
        observer.observe(this.elementRef.nativeElement, config);
    }
    onDomChanges() {
        this.cellLength = this.getCellLength();
        this.carousel.lineUpCells();
        this.ref.detectChanges();
    }
    setDimensions() {
        this.hostStyleHeight = this.height + 'px';
        this.hostStyleWidth = this.width + 'px';
    }
    getFile(index) {
        return this.carousel.getFile(index);
    }
    handleTransitionendCellContainer(event) {
        this.carousel.handleSlideEnd();
    }
    toggleVideo(video) {
        event.preventDefault();
        if (this.videoProperties.noPlay) {
            return;
        }
        if (video.paused) {
            video.play();
            this.isVideoPlaying = true;
        }
        else {
            video.pause();
            this.isVideoPlaying = false;
        }
        this.ref.detectChanges();
    }
    getCurrentIndex() {
        return this.carousel.slideCounter;
    }
    getCellWidth() {
        let elementWidth = this.elementRef.nativeElement.clientWidth;
        if (this.cellsToShow) {
            let margin = this.cellsToShow > 1 ? this.margin : 0;
            let totalMargin = margin * (this.cellsToShow - 1);
            return (elementWidth - totalMargin) / this.cellsToShow;
        }
        if (this._cellWidth === '100%') {
            return elementWidth;
        }
        else {
            return this._cellWidth;
        }
    }
    next() {
        this.carousel.next(this.cellsToScroll);
        this.carousel.stopAutoplay();
    }
    prev() {
        this.carousel.prev(this.cellsToScroll);
        this.carousel.stopAutoplay();
    }
    select(index) {
        this.carousel.select(index);
    }
    isNextArrowDisabled() {
        return this.carousel.isNextArrowDisabled();
    }
    isPrevArrowDisabled() {
        return this.carousel.isPrevArrowDisabled();
    }
    getCellLength() {
        if (this.images) {
            return this.images.length;
        }
        else {
            return this.cellsElement.children.length;
        }
    }
}
CarouselComponent.decorators = [
    { type: Component, args: [{
                selector: 'carousel, [carousel]',
                exportAs: 'carousel',
                template: "<div class=\"carousel-counter\" *ngIf=\"isCounter\">{{counter}}</div>\n\n<div class=\"carousel-container\" [class.carousel-moving]=\"isMoving\">\n\t<div class=\"carousel-cells\" #cells (transitionend)=\"handleTransitionendCellContainer($event)\">\n\t\t<ng-content></ng-content>\n\n\t\t<ng-template ngFor let-image [ngForOf]=\"images\" let-i=\"index\">\n\t\t\t<div class=\"carousel-cell\" \n\t\t\t\t*ngIf=\"i < cellLimit\" \n\t\t\t\t[style.width]=\"getCellWidth()+'px'\"\n\t\t\t\t[style.border-radius]=\"borderRadius+'px'\">\n\n\t\t\t\t<!-- Image -->\n\t\t\t\t<img \n\t\t\t\t\t*ngIf=\"getFile(i) && getFile(i)['image']\" \n\t\t\t\t\t[src]=\"getFile(i)['image']['path']\"\n\t\t\t\t\t[style.object-fit]=\"objectFit\"\n\t\t\t\t\tdraggable=\"false\" />\n\n\t\t\t\t<!-- Video -->\n\t\t\t\t<ng-template [ngIf]=\"getFile(i) && getFile(i)['type'] === 'video'\">\n\t\t\t\t\t<div class=\"carousel-play\" (click)=\"toggleVideo(video)\"></div>\n\n\t\t\t\t\t<video #video\n\t\t\t\t\t\t[loop]=\"videoProperties.loop\"\n\t\t\t\t\t\t[muted]=\"videoProperties.muted\"\n\t\t\t\t\t\t[controls]=\"isSafari\"\n\t\t\t\t\t\t[style.object-fit]=\"objectFit\"\n\t\t\t\t\t\t[style.border-radius]=\"borderRadius+'px'\">\n\t\t\t\t\t\t\n\t\t\t\t\t\t<source [src]=\"getFile(i)['path']\" type=\"video/mp4\">\n\t\t\t\t\t</video>\n\t\t\t\t</ng-template>\n\t\t\t</div>\n\t\t</ng-template>\n\t</div>\n\n\t<div class=\"carousel-dots\" *ngIf=\"dots\">\n\t\t<div class=\"carousel-dot\" [class.carousel-dot-active]=\"i === activeDotIndex\" *ngFor=\"let dot of dotsArr; index as i\"></div>\n\t</div>\n</div>\n\n<div class=\"carousel-arrows\" \n\t[class.carousel-arrows-outside]=\"arrowsOutside\" \n\t[class.carousel-dark-arrows]=\"arrowsTheme === 'dark'\"\n\t*ngIf=\"arrows\">\n\t\n\t<div class=\"carousel-arrow carousel-arrow-prev\" [class.carousel-arrow-disabled]=\"isPrevArrowDisabled()\" (click)=\"prev()\"></div>\n\t<div class=\"carousel-arrow carousel-arrow-next\" [class.carousel-arrow-disabled]=\"isNextArrowDisabled()\" (click)=\"next()\"></div>\n</div>",
                styles: [":host{-moz-user-select:none;-webkit-user-select:none;box-sizing:border-box;display:block;height:100%;left:0;position:relative;top:0;transform-origin:top left;user-select:none;width:100%;z-index:10000}:host .carousel-container{cursor:grab;height:100%;overflow:hidden;width:100%}:host .carousel-container.carousel-moving{cursor:grabbing}:host .carousel-counter{background-color:rgba(23,37,68,.3);border-radius:13px;color:#fff;font-size:11px;line-height:normal;padding:5px 7px;position:absolute;right:24px;text-align:right;top:8px;transition:opacity .2s;z-index:30}:host ::ng-deep .carousel-cells{display:block;height:100%;transition:transform .2s;width:100%}:host ::ng-deep .carousel-cells .carousel-cell.swiper-prev-image{transform:translate3d(-100%,0,0)}:host ::ng-deep .carousel-cells .carousel-cell.swiper-next-image{transform:translate3d(100%,0,0)}:host ::ng-deep .carousel-cells .carousel-cell{height:100%;overflow:hidden;position:absolute;width:100%}:host ::ng-deep .carousel-cells .carousel-cell img,:host ::ng-deep .carousel-cells .carousel-cell video{height:100%;object-fit:contain;position:relative;width:100%}:host ::ng-deep .carousel-cells .carousel-cell img.swiper-hide{display:none}:host ::ng-deep .carousel-cells .carousel-cell .carousel-play{bottom:0;left:0;position:absolute;right:0;top:0;z-index:1}:host .carousel-arrow{background-color:#fff;background-position:50%;background-repeat:no-repeat;background-size:31px;border-radius:100px;box-shadow:0 0 5px rgba(0,0,0,.15);cursor:pointer;height:40px;margin-top:-20px;position:absolute;top:50%;width:40px;z-index:10}:host .carousel-arrow-prev{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0Ij48cGF0aCBkPSJNMTUuNDEgMTYuNTlMMTAuODMgMTJsNC41OC00LjU5TDE0IDZsLTYgNiA2IDYgMS40MS0xLjQxeiIvPjxwYXRoIGQ9Ik0wIDBoMjR2MjRIMFYweiIgZmlsbD0ibm9uZSIvPjwvc3ZnPg==);left:10px}:host .carousel-arrow-next{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0Ij48cGF0aCBkPSJNOC41OSAxNi41OUwxMy4xNyAxMiA4LjU5IDcuNDEgMTAgNmw2IDYtNiA2LTEuNDEtMS40MXoiLz48cGF0aCBkPSJNMCAwaDI0djI0SDBWMHoiIGZpbGw9Im5vbmUiLz48L3N2Zz4=);right:10px}:host .carousel-arrows-outside .carousel-arrow-prev{left:-60px}:host .carousel-arrows-outside .carousel-arrow-next{right:-60px}:host .carousel-dark-arrows .carousel-arrow{filter:invert(1)}:host .carousel-arrow-disabled{cursor:default;opacity:.5}:host .carousel-dots{bottom:0;left:0;position:absolute;right:0;text-align:center;z-index:10}:host .carousel-dots .carousel-dot{border:2px solid #fff;border-radius:100px;display:inline-block;height:8px;margin:4px;width:8px}:host .carousel-dots .carousel-dot-active{background-color:#fff}"]
            },] }
];
CarouselComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef }
];
CarouselComponent.propDecorators = {
    images: [{ type: Input }],
    events: [{ type: Output }],
    height: [{ type: Input }],
    width: [{ type: Input }],
    loop: [{ type: Input }],
    autoplay: [{ type: Input }],
    autoplayInterval: [{ type: Input }],
    pauseOnHover: [{ type: Input }],
    dots: [{ type: Input }],
    borderRadius: [{ type: Input }],
    margin: [{ type: Input }],
    objectFit: [{ type: Input }],
    minSwipeDistance: [{ type: Input }],
    transitionDuration: [{ type: Input }],
    transitionTimingFunction: [{ type: Input }],
    videoProperties: [{ type: Input }],
    counterSeparator: [{ type: Input }],
    overflowCellsLimit: [{ type: Input }],
    listeners: [{ type: Input }],
    cellsToShow: [{ type: Input }],
    cellsToScroll: [{ type: Input }],
    cellWidth: [{ type: Input, args: ['cellWidth',] }],
    isCounter: [{ type: Input, args: ['counter',] }],
    arrows: [{ type: Input }],
    arrowsOutside: [{ type: Input }],
    arrowsTheme: [{ type: Input }],
    hostClassCarousel: [{ type: HostBinding, args: ['class.carousel',] }],
    hostStyleHeight: [{ type: HostBinding, args: ['style.height',] }],
    hostStyleWidth: [{ type: HostBinding, args: ['style.width',] }],
    onWindowResize: [{ type: HostListener, args: ['window:resize', ['$event'],] }],
    onMousemove: [{ type: HostListener, args: ['mousemove', ['$event'],] }],
    onMouseleave: [{ type: HostListener, args: ['mouseleave', ['$event'],] }]
};

class IvyCarouselModule {
}
IvyCarouselModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    CarouselComponent
                ],
                imports: [
                    CommonModule
                ],
                exports: [
                    CarouselComponent
                ],
                providers: [],
                bootstrap: [],
                entryComponents: [
                    CarouselComponent
                ]
            },] }
];

/*
 * Public API Surface of angular-responsive-carousel
 */

/**
 * Generated bundle index. Do not edit.
 */

export { CarouselComponent, IvyCarouselModule };
//# sourceMappingURL=angular-responsive-carousel.js.map
